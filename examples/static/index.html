<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whisper JAX</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: #f8fafc;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header - minimal with title and status */
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.5rem;
            background: #0f172a;
            border-bottom: 1px solid #1e293b;
            flex-shrink: 0;
        }

        h1 {
            font-size: 1.25rem;
            font-weight: 600;
            background: linear-gradient(135deg, #3b82f6, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: #94a3b8;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #94a3b8;
            transition: background 0.3s, box-shadow 0.3s;
        }

        .status-dot.connected {
            background: #22c55e;
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
        }

        .status-dot.recording {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
            animation: pulse 1s infinite;
        }

        .status-dot.loading {
            background: #3b82f6;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Transcript area - scrollable middle section */
        .transcript {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            overflow-y: auto;
            padding: 1rem;
            padding-bottom: 180px;
            /* Space for bottom controls */
        }

        .segment {
            padding: 1rem 1.25rem;
            background: #1e293b;
            border-radius: 12px;
            margin-bottom: 0.75rem;
            animation: slideIn 0.3s ease-out;
            line-height: 1.6;
            font-size: 1rem;
        }

        .segment.processing {
            color: #94a3b8;
            font-style: italic;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-16px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .placeholder {
            color: #475569;
            text-align: center;
            padding: 3rem;
            font-size: 1.1rem;
        }

        /* Bottom controls - fixed footer */
        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
            padding: 1.5rem;
            background: linear-gradient(to top, #0f172a 60%, transparent);
            padding-top: 3rem;
        }

        /* Pill-style selectors */
        .pill-select {
            padding: 0.6rem 1rem;
            background: #1e293b;
            color: #e2e8f0;
            border: 1px solid #334155;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
            transition: all 0.2s;
            min-width: 100px;
            text-align: center;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            padding-right: 2rem;
        }

        .pill-select:hover {
            background-color: #334155;
            border-color: #475569;
        }

        .pill-select:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .pill-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Mic button container with circular waveform */
        .mic-container {
            position: relative;
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wave-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .mic-button {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #3b82f6, #6366f1);
            color: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 1;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }

        .mic-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 28px rgba(59, 130, 246, 0.4);
        }

        .mic-button:active:not(:disabled) {
            transform: scale(0.98);
        }

        .mic-button:disabled {
            background: #334155;
            cursor: not-allowed;
            box-shadow: none;
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #ef4444, #f97316);
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.5);
            animation: glow 1.5s infinite;
        }

        @keyframes glow {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.5), 0 4px 20px rgba(239, 68, 68, 0.3);
            }

            50% {
                box-shadow: 0 0 0 12px rgba(239, 68, 68, 0), 0 4px 20px rgba(239, 68, 68, 0.3);
            }
        }

        .mic-button svg {
            width: 32px;
            height: 32px;
        }

        /* Progress ring around mic */
        .progress-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .progress-ring circle {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: center;
        }

        .progress-ring .bg {
            stroke: #334155;
        }

        .progress-ring .progress {
            stroke: #3b82f6;
            transition: stroke-dashoffset 0.1s;
        }
    </style>
</head>

<body>
    <header>
        <h1>Whisper JAX</h1>
        <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Connecting...</span>
        </div>
    </header>

    <div class="transcript" id="transcript">
        <p class="placeholder">Tap the microphone to start transcribing</p>
    </div>

    <div class="controls">
        <select id="modelSelect" class="pill-select">
            <option value="tiny">Tiny</option>
            <option value="base">Base</option>
            <option value="small">Small</option>
            <option value="medium">Medium</option>
            <option value="large-v3">Large v3</option>
        </select>

        <div class="mic-container">
            <canvas class="wave-canvas" id="waveCanvas" width="240" height="240"></canvas>
            <svg class="progress-ring" id="progressRing" viewBox="0 0 120 120">
                <circle class="bg" cx="60" cy="60" r="54" />
                <circle class="progress" cx="60" cy="60" r="54" stroke-dasharray="339.292"
                    stroke-dashoffset="339.292" />
            </svg>
            <button class="mic-button" id="micButton" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"
                    stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round"
                        d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                </svg>
            </button>
        </div>

        <select id="langSelect" class="pill-select">
            <option value="en">English</option>
            <option value="fr">French</option>
            <option value="de">German</option>
            <option value="es">Spanish</option>
            <option value="it">Italian</option>
            <option value="pt">Portuguese</option>
            <option value="nl">Dutch</option>
            <option value="pl">Polish</option>
            <option value="ru">Russian</option>
            <option value="zh">Chinese</option>
            <option value="ja">Japanese</option>
            <option value="ko">Korean</option>
        </select>
    </div>

    <script>
        const micButton = document.getElementById('micButton');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const transcript = document.getElementById('transcript');
        const langSelect = document.getElementById('langSelect');
        const modelSelect = document.getElementById('modelSelect');
        const waveCanvas = document.getElementById('waveCanvas');
        const progressRing = document.getElementById('progressRing');
        const progressCircle = progressRing.querySelector('.progress');

        const CIRCLE_CIRCUMFERENCE = 2 * Math.PI * 54; // r=54
        const COOKIE_DAYS = 365;

        let ws = null;
        let audioContext = null;
        let analyser = null;
        let isRecording = false;
        let animationId = null;
        let currentSegmentEl = null;

        // Cookie utilities
        function setCookie(name, value, days = COOKIE_DAYS) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/; SameSite=Lax`;
        }

        function getCookie(name) {
            const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
            return match ? decodeURIComponent(match[2]) : null;
        }

        // Load saved preferences
        function loadPreferences() {
            const savedModel = getCookie('whisper_model');
            const savedLang = getCookie('whisper_lang');

            if (savedModel && modelSelect.querySelector(`option[value="${savedModel}"]`)) {
                modelSelect.value = savedModel;
            }
            if (savedLang && langSelect.querySelector(`option[value="${savedLang}"]`)) {
                langSelect.value = savedLang;
            }
        }

        // WebSocket connection
        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}/ws`);

            ws.onopen = () => {
                statusDot.className = 'status-dot connected';
                statusText.textContent = 'Ready';
                micButton.disabled = false;
                modelSelect.disabled = false;
                langSelect.disabled = false;

                // Request saved model if different from server default
                const savedModel = getCookie('whisper_model');
                if (savedModel && savedModel !== 'tiny') {
                    statusText.textContent = 'Loading model...';
                    statusDot.className = 'status-dot loading';
                    micButton.disabled = true;
                    modelSelect.disabled = true;
                    langSelect.disabled = true;
                    ws.send(JSON.stringify({ type: 'model', value: savedModel }));
                }

                // Send saved language preference
                ws.send(JSON.stringify({ type: 'lang', value: langSelect.value }));
            };

            ws.onmessage = (e) => {
                const data = JSON.parse(e.data);

                if (data.type === 'progress') {
                    updateProgress(data.value);
                } else if (data.type === 'processing') {
                    showProcessing();
                } else if (data.type === 'transcription') {
                    finalize(data.text);
                } else if (data.type === 'status') {
                    statusText.textContent = data.message;

                    if (data.message === 'Ready') {
                        statusDot.className = 'status-dot connected';
                        micButton.disabled = false;
                        modelSelect.disabled = false;
                        langSelect.disabled = false;
                    } else if (data.message.includes('Loading') || data.message.includes('Warming')) {
                        statusDot.className = 'status-dot loading';
                        micButton.disabled = true;
                        modelSelect.disabled = true;
                        langSelect.disabled = true;
                    }
                }
            };

            ws.onclose = () => {
                statusDot.className = 'status-dot';
                statusText.textContent = 'Disconnected';
                micButton.disabled = true;
                modelSelect.disabled = true;
                langSelect.disabled = true;
                setTimeout(connect, 2000);
            };
        }

        // Progress updates
        function updateProgress(value) {
            // Update progress ring
            const offset = CIRCLE_CIRCUMFERENCE * (1 - value);
            progressCircle.style.strokeDashoffset = offset;
        }

        function resetProgress() {
            progressCircle.style.strokeDashoffset = CIRCLE_CIRCUMFERENCE;
        }

        // Segment management
        function ensureSegment() {
            if (!currentSegmentEl) {
                const placeholder = transcript.querySelector('.placeholder');
                if (placeholder) placeholder.remove();

                currentSegmentEl = document.createElement('div');
                currentSegmentEl.className = 'segment processing';
                currentSegmentEl.textContent = 'Listening...';
                transcript.prepend(currentSegmentEl);
            }
            return currentSegmentEl;
        }

        function showProcessing() {
            const seg = ensureSegment();
            seg.textContent = 'Processing...';
            updateProgress(1);
        }

        function finalize(text) {
            if (currentSegmentEl) {
                currentSegmentEl.className = 'segment';
                currentSegmentEl.textContent = text || '(no speech detected)';
                currentSegmentEl = null;
            }
            resetProgress();
            statusDot.className = 'status-dot connected';
            statusText.textContent = 'Ready';
        }

        // Circular waveform visualization
        function drawCircularWave() {
            if (!analyser || !isRecording) return;

            const ctx = waveCanvas.getContext('2d');
            const width = waveCanvas.width;
            const height = waveCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const baseRadius = 72; // Match mic button size
            const maxAmplitude = 20;

            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteTimeDomainData(data);

            ctx.clearRect(0, 0, width, height);

            // Draw circular waveform
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
            ctx.lineWidth = 2;

            const sliceCount = 64;
            const sliceAngle = (2 * Math.PI) / sliceCount;

            for (let i = 0; i <= sliceCount; i++) {
                const dataIndex = Math.floor((i / sliceCount) * data.length);
                const amplitude = (data[dataIndex] - 128) / 128;
                const radius = baseRadius + amplitude * maxAmplitude;
                const angle = i * sliceAngle - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.closePath();
            ctx.stroke();

            // Inner glow
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.2)';
            ctx.lineWidth = 8;

            for (let i = 0; i <= sliceCount; i++) {
                const dataIndex = Math.floor((i / sliceCount) * data.length);
                const amplitude = (data[dataIndex] - 128) / 128;
                const radius = baseRadius + amplitude * maxAmplitude * 0.5;
                const angle = i * sliceAngle - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.closePath();
            ctx.stroke();

            animationId = requestAnimationFrame(drawCircularWave);
        }

        function clearWave() {
            const ctx = waveCanvas.getContext('2d');
            ctx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
        }

        // Resample audio from source rate to target rate
        function resample(input, srcRate, dstRate) {
            if (srcRate === dstRate) return input;
            const ratio = srcRate / dstRate;
            const outputLength = Math.round(input.length / ratio);
            const output = new Float32Array(outputLength);
            for (let i = 0; i < outputLength; i++) {
                const srcIndex = i * ratio;
                const low = Math.floor(srcIndex);
                const high = Math.min(low + 1, input.length - 1);
                const t = srcIndex - low;
                output[i] = input[low] * (1 - t) + input[high] * t;
            }
            return output;
        }

        // Recording
        async function startRecording() {
            try {
                // Send language selection to backend
                if (ws?.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'lang', value: langSelect.value }));
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                // Use browser's native sample rate, resample to 16kHz when sending
                audioContext = new AudioContext();
                const nativeSampleRate = audioContext.sampleRate;

                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;

                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);

                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                source.connect(processor);
                processor.connect(audioContext.destination);

                processor.onaudioprocess = (e) => {
                    if (!isRecording || ws.readyState !== WebSocket.OPEN) return;
                    const input = e.inputBuffer.getChannelData(0);
                    // Resample to 16kHz
                    const resampled = resample(input, nativeSampleRate, 16000);
                    const pcm = new Int16Array(resampled.length);
                    for (let i = 0; i < resampled.length; i++) {
                        pcm[i] = Math.max(-1, Math.min(1, resampled[i])) * 0x7FFF;
                    }
                    ws.send(pcm.buffer);
                };

                isRecording = true;
                micButton.classList.add('recording');
                statusDot.className = 'status-dot recording';
                statusText.textContent = 'Recording...';

                ensureSegment();
                drawCircularWave();

            } catch (err) {
                console.error('Microphone access denied:', err);
                statusText.textContent = 'Microphone access denied';
            }
        }

        function stopRecording() {
            isRecording = false;
            micButton.classList.remove('recording');
            statusDot.className = 'status-dot connected';
            statusText.textContent = 'Processing...';

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            clearWave();

            if (audioContext) {
                audioContext.close();
                audioContext = null;
                analyser = null;
            }

            if (currentSegmentEl) {
                showProcessing();
            }

            if (ws?.readyState === WebSocket.OPEN) {
                ws.send('flush');
            }
        }

        // Event handlers
        micButton.onclick = () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        };

        langSelect.onchange = () => {
            setCookie('whisper_lang', langSelect.value);
            if (ws?.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'lang', value: langSelect.value }));
            }
        };

        modelSelect.onchange = () => {
            setCookie('whisper_model', modelSelect.value);
            if (ws?.readyState === WebSocket.OPEN) {
                statusText.textContent = 'Loading model...';
                statusDot.className = 'status-dot loading';
                micButton.disabled = true;
                modelSelect.disabled = true;
                langSelect.disabled = true;
                ws.send(JSON.stringify({ type: 'model', value: modelSelect.value }));
            }
        };

        // Initialize
        loadPreferences();
        connect();
    </script>
</body>

</html>